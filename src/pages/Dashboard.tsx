import { useState, useEffect, useRef } from "react";
import { Navigate } from "react-router-dom";
import { useAuth } from "@/hooks/useAuth";
import { useProducers } from "@/hooks/useProducers";
import { useDemands } from "@/hooks/useDemands";
import EditDemandDialog from "@/components/EditDemandDialog";
import CreateDemandDialog from "@/components/CreateDemandDialog";
import DemandTabContent from "@/components/dashboard/DemandTabContent";
import { handleApiError } from "@/lib/errors";
import { toast } from "sonner";
import type { DemandRow } from "@/types/demands";
import { getPeriodStart, countDueSoon } from "@/lib/demands";
import { supabase } from "@/integrations/supabase/client";
import { useQueryClient } from "@tanstack/react-query";
import { queryKeys } from "@/lib/query-keys";

export default function Dashboard() {
  const { user, loading: authLoading, role, displayName, signOut } = useAuth();
  const { data: producers = [] } = useProducers(role);
  const queryClient = useQueryClient();
  const {
    demands,
    deliverables,
    isLoading: demandsLoading,
    refetch,
    updateStatusMutation,
    updatePhaseMutation,
    deleteDemandMutation,
  } = useDemands();

  const [updatingId, setUpdatingId] = useState<string | null>(null);
  const [editingDemand, setEditingDemand] = useState<DemandRow | null>(null);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [createInitialDueDate, setCreateInitialDueDate] = useState<Date | null>(null);
  const [filterStatus, setFilterStatus] = useState<string>("all");
  const [filterProducer, setFilterProducer] = useState<string>("all");
  const [dateFilter, setDateFilter] = useState<string>("all");
  const lastUpdatedByUsRef = useRef<Map<string, number>>(new Map());

  const canEditOrDelete = role === "ceo" || role === "atendente" || role === "admin";

  useEffect(() => {
    const channel = supabase
      .channel("demands-changes")
      .on(
        "postgres_changes",
        { event: "UPDATE", schema: "public", table: "demands" },
        (payload) => {
          const newRow = payload.new as DemandRow;
          const id = newRow?.id;
          if (!id) return;
          const now = Date.now();
          if (lastUpdatedByUsRef.current.get(id) && now - lastUpdatedByUsRef.current.get(id)! < 2500) return;
          queryClient.invalidateQueries({ queryKey: queryKeys.demands.all });
          queryClient.invalidateQueries({ queryKey: queryKeys.deliverables.all });
          const statusLabel = newRow.status === "concluido" ? "Concluída" : newRow.status === "em_producao" ? "Em produção" : "Aguardando";
          toast.info(`Demanda atualizada: ${newRow.name} → ${statusLabel}`);
        }
      )
      .subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [queryClient]);

  if (authLoading) return <div className="flex min-h-screen items-center justify-center"><div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full" /></div>;
  if (!user) return <Navigate to="/auth" replace />;

  const periodStart = getPeriodStart(dateFilter);
  const filtered = demands.filter((d) => {
    if (filterStatus !== "all" && d.status !== filterStatus) return false;
    if (filterProducer !== "all" && d.producer_name !== filterProducer) return false;
    if (periodStart && new Date(d.created_at) < periodStart) return false;
    return true;
  });

  const dueSoonCount = countDueSoon(demands);
  const demandsForReport =
    role === "produtor" && displayName != null
      ? demands.filter((d) => d.producer_name === displayName)
      : demands;

  const counts = {
    aguardando: demands.filter((d) => d.status === "aguardando").length,
    em_producao: demands.filter((d) => d.status === "em_producao").length,
    concluido: demands.filter((d) => d.status === "concluido").length,
  };

  const roleLabel = role === "atendente" ? "Atendente" : role === "produtor" ? "Produtor" : role === "admin" ? "Desenvolvedor" : "CEO";

  const handleStatusCardClick = (status: string) => {
    setFilterStatus((prev) => (prev === status ? "all" : status));
  };

  const openCreateDialog = (initialDueDate?: Date | null) => {
    setCreateInitialDueDate(initialDueDate ?? null);
    setCreateDialogOpen(true);
  };

  const handleUpdateStatus = async (id: string, newStatus: string) => {
    lastUpdatedByUsRef.current.set(id, Date.now());
    setUpdatingId(id);
    try {
      await updateStatusMutation.mutateAsync({
        id,
        status: newStatus as "aguardando" | "em_producao" | "concluido",
      });
      toast.success("Status atualizado!");
    } catch (e) {
      handleApiError(e, "Erro ao atualizar status");
    }
    setUpdatingId(null);
  };

  return (
    <div className="min-h-screen bg-background">
      <DemandTabContent
        role={role}
        displayName={displayName}
        userId={user.id}
        signOut={signOut}
        demands={demands}
        deliverables={deliverables}
        demandsForReport={demandsForReport}
        demandsLoading={demandsLoading}
        filtered={filtered}
        counts={counts}
        dueSoonCount={dueSoonCount}
        filterStatus={filterStatus}
        setFilterStatus={setFilterStatus}
        filterProducer={filterProducer}
        setFilterProducer={setFilterProducer}
        dateFilter={dateFilter}
        setDateFilter={setDateFilter}
        producers={producers}
        canEditOrDelete={canEditOrDelete}
        updatingId={updatingId}
        editingDemand={editingDemand}
        setEditingDemand={setEditingDemand}
        refetch={refetch}
        updateStatusMutation={updateStatusMutation}
        updatePhaseMutation={updatePhaseMutation}
        deleteDemandMutation={deleteDemandMutation}
        handleStatusCardClick={handleStatusCardClick}
        handleUpdateStatus={handleUpdateStatus}
        roleLabel={roleLabel}
        onOpenCreateDialog={openCreateDialog}
      />
      <CreateDemandDialog
        open={createDialogOpen}
        onOpenChange={(open) => {
          setCreateDialogOpen(open);
          if (!open) setCreateInitialDueDate(null);
        }}
        initialDueDate={createInitialDueDate}
        onCreated={() => { refetch(); setCreateDialogOpen(false); setCreateInitialDueDate(null); }}
      />
      <EditDemandDialog
        demand={editingDemand}
        open={!!editingDemand}
        onOpenChange={(open) => !open && setEditingDemand(null)}
        onUpdated={() => { refetch(); setEditingDemand(null); }}
      />
    </div>
  );
}
